{"componentChunkName":"component---src-pages-articles-markdown-remark-parent-file-name-index-tsx","path":"/articles/start-linux/","result":{"data":{"markdownRemark":{"id":"fde41c7a-6536-5376-a745-73cbb0e6c57e","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<ul>\n<li><a href=\"#%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%BB%84%E6%88%90\">定义及组成</a></li>\n<li><a href=\"#arm-%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84\">ARM 的硬件结构</a></li>\n<li><a href=\"#linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\">Linux 文件系统结构</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">常用命令</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\">开发环境</a></p>\n<ul>\n<li>\n<p><a href=\"#gcc-%E7%9A%84%E4%BD%BF%E7%94%A8\">GCC 的使用</a></p>\n</li>\n<li>\n<p><a href=\"#gdb-%E7%9A%84%E4%BD%BF%E7%94%A8\">GDB 的使用</a></p>\n</li>\n<li>\n<p><a href=\"#qt-%E7%9A%84%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">QT 的简单程序设计</a></p>\n</li>\n<li>\n<p><a href=\"#sql-%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%89%E8%A3%85\">SQL 结构化查询语言的安装</a></p>\n</li>\n<li>\n<p><a href=\"#minicom-%E7%9A%84%E9%85%8D%E7%BD%AE\">minicom 的配置</a></p>\n</li>\n<li>\n<p><a href=\"#busybox-%E5%AE%89%E8%A3%85\">BusyBox 安装</a></p>\n</li>\n<li>\n<p><a href=\"#qt-%E7%9A%84%E5%AE%89%E8%A3%85\">QT 的安装</a></p>\n</li>\n<li>\n<p><a href=\"#nfs\">NFS</a></p>\n</li>\n<li>\n<p><a href=\"#tftp\">TFTP</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BB%A3%E7%A0%81\">字符设备的代码</a></p>\n</li>\n<li>\n<p><a href=\"#%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8\">按键驱动</a></p>\n</li>\n<li>\n<p><a href=\"#led-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD\">LED 驱动程序的动态加载</a></p>\n</li>\n<li>\n<p><a href=\"#makefile-%E6%B3%A8%E9%87%8A%E6%A0%B7%E4%BE%8B\">makefile 注释样例</a></p>\n<ul>\n<li><a href=\"#%E6%A0%B7%E4%BE%8B-1\">样例 1</a></li>\n<li><a href=\"#%E6%A0%B7%E4%BE%8B-2\">样例 2</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","timeToRead":9,"excerpt":"基本概念 定义及组成 嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用型计算机系统 组成：嵌入式微处理器、外围硬件设备、嵌入式操作系统、特定的应用程序 三要素：嵌入性、专用性、计算机系统 嵌入式系统的开发模式分为：本地开发和交…","fields":{"slug":"/articles/Start-Linux"},"frontmatter":{"title":"嵌入式「Linux」基础","author":"赤琦","date":"January 06, 2019","original":null,"description":null,"draft":null,"slug":null,"categories":["develop"],"series":null,"tags":["Linux","嵌入式"]},"headings":[{"id":null,"value":"基本概念","depth":2},{"id":null,"value":"定义及组成","depth":3},{"id":null,"value":"ARM 的硬件结构","depth":3},{"id":null,"value":"Linux 文件系统结构","depth":3},{"id":null,"value":"常用命令","depth":3},{"id":null,"value":"开发环境","depth":2},{"id":null,"value":"GCC 的使用","depth":3},{"id":null,"value":"GDB 的使用","depth":3},{"id":null,"value":"QT 的简单程序设计","depth":3},{"id":null,"value":"SQL 结构化查询语言的安装","depth":3},{"id":null,"value":"minicom 的配置","depth":3},{"id":null,"value":"BusyBox 安装","depth":3},{"id":null,"value":"QT 的安装","depth":3},{"id":null,"value":"NFS","depth":3},{"id":null,"value":"TFTP","depth":3},{"id":null,"value":"字符设备的代码","depth":3},{"id":null,"value":"按键驱动","depth":3},{"id":null,"value":"LED 驱动程序的动态加载","depth":3},{"id":null,"value":"makefile 注释样例","depth":3},{"id":null,"value":"样例 1","depth":4},{"id":null,"value":"样例 2","depth":4}],"wordCount":{"words":362,"sentences":123,"paragraphs":123},"html":"<h2>基本概念</h2>\n<h3>定义及组成</h3>\n<ul>\n<li>\n<p>嵌入式系统是以<strong>应用</strong>为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用型计算机系统</p>\n</li>\n<li>\n<p>组成：嵌入式微处理器、外围硬件设备、嵌入式操作系统、特定的应用程序</p>\n</li>\n<li>\n<p>三要素：<strong>嵌入性</strong>、<strong>专用性</strong>、<strong>计算机系统</strong></p>\n</li>\n<li>\n<p>嵌入式系统的开发模式分为：本地开发和交叉开发</p>\n</li>\n<li>\n<p>构建交叉编译环境的主要内容：构建交叉编译器、串口、网络的通信方式</p>\n</li>\n<li>\n<p>构建交叉编译环境的硬件设备：JTAG 线、串口、网络线</p>\n</li>\n<li>\n<p>串口的作用：实现双向通信</p>\n</li>\n<li>\n<p>网络的作用：实验资源共享和数据通信</p>\n</li>\n<li>\n<p>系统设备驱动的分类：</p>\n<ul>\n<li>\n<p>字符类设备：例如键盘、LED 等，目的是为了操作方便</p>\n</li>\n<li>\n<p>块设备：FLASH、DOC 等，经过缓存，给系统的存储提供优化</p>\n</li>\n<li>\n<p>网络设备：实现多个系统通信</p>\n</li>\n<li>\n<p>其他设备</p>\n</li>\n</ul>\n</li>\n<li>\n<p>设备驱动的基本结构：</p>\n<ul>\n<li>\n<p>驱动程序的注册和注销</p>\n</li>\n<li>\n<p>设备的打开与释放</p>\n</li>\n<li>\n<p>设备的读写操作</p>\n</li>\n<li>\n<p>设备的控制操作</p>\n</li>\n<li>\n<p>设备的中断和轮询处理</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>ARM 的硬件结构</h3>\n<ul>\n<li>\n<p>ARM 是 32 位 <strong>RISC</strong> 处理器</p>\n</li>\n<li>\n<p>类型：ARM 710 系列、ARM 940T、920T 系列、StrongARM</p>\n</li>\n<li>\n<p>S3C6410 有 <strong>10</strong> 组外部中断，有 17 组外部 I/O 引脚,GPA ~ GPQ</p>\n</li>\n<li>\n<p>S3C6410 寄存器：</p>\n<ul>\n<li>\n<p>GPxCON：端口配置寄存器</p>\n</li>\n<li>\n<p>GPxDAT：端口数据寄存器</p>\n</li>\n<li>\n<p>GPxPUD：上/下拉寄存器</p>\n</li>\n<li>\n<p>GPxCONSLP：睡眠模式配置寄存器</p>\n</li>\n<li>\n<p>GPxPUDSLP：睡眠模式上/下拉寄存器</p>\n</li>\n</ul>\n</li>\n<li>\n<p>S3C6410 的中断控制寄存器类型：<strong>EINT 控制寄存器</strong>；其工作模式是：<strong>高/低电平</strong></p>\n</li>\n<li>\n<p>BootLoader 的两种模式：启动加载模式和下载模式</p>\n<ul>\n<li>\n<p>作用：在操作系统内核运行之前，初始硬件设备，建立内存的寻址空间映射，划出操作系统的内存地址范围，加载操作系统到 RAM 中让系统自举启动</p>\n</li>\n<li>\n<p>Stage 1：</p>\n<p>1、 硬件设备的初始化：屏蔽所有中断、设置 CPU 速度和时钟频率、RAM 地址的初始化</p>\n<p>2、 初始化 Stage 2 的内存地址范围</p>\n<p>3、 加载 Stage 2 到 RAM 中</p>\n<p>4、 设置堆栈</p>\n<p>5、 跳转到 Stage 2 的 c 入口</p>\n</li>\n<li>\n<p>Stage 2：</p>\n<p>1、 初始化需要用到的硬件设备</p>\n<p>2、 检测系统的内存映射</p>\n<p>3、 将 kernel 映像和根文件系统映像加载到 RAM</p>\n<p>4、 设置启动参数</p>\n<p>5、 调用内核</p>\n</li>\n</ul>\n</li>\n<li>\n<p>移植：将源代码编译到不同的硬件设备平台运行</p>\n<ul>\n<li>\n<p>内核移植：根据硬件平台对内核进行增加模块、裁剪、配置并重新编译以实现对硬件平台的支持</p>\n<p>1、 修改 Kconfig 文件</p>\n<p>2、 修改 makefile 文件</p>\n<p>3、 make menuconfig 配置</p>\n<p>4、 make zimage 生成映像</p>\n<p>5、 烧写映像文件到开发板</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Linux 文件系统结构</h3>\n<ul>\n<li>\n<p>/bin 存放二进制文件和普通用户常用的命令</p>\n</li>\n<li>\n<p>/boot 存放内核和引导文件（例如 GRUB）</p>\n</li>\n<li>\n<p>/dev 存放设备文件</p>\n</li>\n<li>\n<p>/etc 存放系统配置文件，该目录有重要文件，例如<code>init.d</code></p>\n</li>\n<li>\n<p>/home 普通用户的默认目录</p>\n</li>\n<li>\n<p>/lib 存放库文件</p>\n</li>\n<li>\n<p>/lost+found 存放系统奔溃或者意外关机产生的碎片文件</p>\n</li>\n<li>\n<p>/mnt 存储设备的挂载目录</p>\n</li>\n<li>\n<p>/opt 可选目录，即用户可以自定义的安装目录</p>\n</li>\n<li>\n<p>/proc 系统运行时的内核和进程信息</p>\n</li>\n<li>\n<p>/root 超级权限 root 用户的目录</p>\n</li>\n<li>\n<p>/sbin 存放仅超级权限用户可以执行的管理系统的命令</p>\n</li>\n<li>\n<p>/tmp 存放程序运行时的临时文件</p>\n</li>\n<li>\n<p>/usr 系统存放与程序相关的文件</p>\n</li>\n<li>\n<p>/sys 存放系统核心文件</p>\n</li>\n<li>\n<p>/media 用于挂载</p>\n</li>\n<li>\n<p>/cdrom 光驱目录</p>\n</li>\n<li>\n<p>/var 大文件的溢出区</p>\n</li>\n<li>\n<p>/usr/local 默认的编译安装目录</p>\n</li>\n</ul>\n<h3>常用命令</h3>\n<pre><code class=\"language-bash\">cp bg.png img\r\n# 复制 bg.png 到 img 目录下\r\n\r\nmv costom.css css/index.css\r\n# 移动 custom.css 文件到 css 目录下 并重命名为 index.css\r\n\r\ncd ../\r\n# 放回上一级目录\r\n\r\nls\r\n# 列出所有目录和文件\r\n\r\nmkdir xxx\r\n# 新建 xxx 目录\r\n\r\nrmdir xxx\r\n# 删除 xxx 目录\r\n\r\nman rm\r\n# 查看 rm 命令的帮助文档\r\n\r\npwd\r\n# 列出工作路径\r\n\r\nfind xxx\r\n# 查找 xxx 文件\r\n\r\nrm -rf xxx\r\n# 强制删除 xxx 目录所有内容\r\n\r\nifconfig\r\n# 列出网卡配置（同时也可以配置）\r\n\r\nping xxx\r\n# 网络链路测试\r\n\r\nlsmod\r\n# 列出模块\r\n\r\ninsmod xxx\r\n# 安装模块\r\n\r\nrmmod xxx\r\n# 移除模块\r\n\r\ntar -zxvf xxx.tar.gz\r\n# 解压 xxx.tar.gz\r\n\r\ntar -jxvf xxx.tar.bz2\r\n# 解压 xxx.tar.bz2\r\n\n</code></pre>\n<h2>开发环境</h2>\n<h3>GCC 的使用</h3>\n<pre><code class=\"language-bash\">gcc -E main.c -o main.i\r\n# 预处理时停止\r\n\r\ngcc -S main.i -o main.s\r\n# 编译到汇编阶段停止\r\n\r\ngcc -c main.s -o main.o\r\n# 汇编成目标文件\r\n\r\ngcc main.o -o main\r\n# 链接成为可执行的二进制文件\r\n\n</code></pre>\n<h3>GDB 的使用</h3>\n<pre><code class=\"language-bash\">gcc -Wall -g main.c -o main\r\n\r\ngdb -q main\r\n(gdb) l\r\n# 列出源程序\r\n(gdb) b 行号\r\n# 在某行断点\r\n(gdb) n\r\n# 执行下一单步\r\n(gdb) r\r\n# 继续执行\r\n(gdb) p xxx\r\n# 打印 xxx 的值\r\n(gdb) q\r\n# 推出\r\n\n</code></pre>\n<h3>QT 的简单程序设计</h3>\n<p>QT 是一个跨平台的 C++ 的图形用户界面库</p>\n<pre><code class=\"language-bash\">vi xxx.c\r\n# 创建 QT 程序\r\n\r\nqmake -project\r\n# 生成 .pro 的专案文件\r\n\r\nqmake\r\n# 生成 makefile 文件\r\n\r\nmake\r\n# 执行编译\n</code></pre>\n<h3>SQL 结构化查询语言的安装</h3>\n<p>安装 SQLite</p>\n<pre><code class=\"language-bash\">示范包: sqlite.tar.gz\r\n\r\ntar -zvxf sqlite.tar.gz\r\n\r\ncd sqlite\r\n\r\n./configure --host=arm-linux --prefix=/opt/sqlite --disable-tcl\r\n\r\nmake &#x26;&#x26; make install\r\n\r\ncp -f /opt/sqlite/bin /mnt/s3c6410/bin\r\n\r\ncp -f /opt/sqlite/lib /mnt/s3c6410/lib\r\n\r\n# 切换到开发板的终端\r\n\r\nsqlite3\n</code></pre>\n<h3>minicom 的配置</h3>\n<p>目标板与宿主机相连：PC COM ——》 ARM UART0</p>\n<p>运行终端</p>\n<pre><code class=\"language-bash\">minicom\n</code></pre>\n<p>按下 o 键，进行串口的配置。其中波特率为 115200，8bit，无流控制</p>\n<p>保存，退出</p>\n<h3>BusyBox 安装</h3>\n<p>1、 获取源码包，示范 busybox.tar.bz2</p>\n<p>2、 解压源码包 <code>tar -jxvf busybox.tar.bz2</code></p>\n<p>3、 <code>cd busybox &#x26;&#x26; make menuconfig</code> 配置</p>\n<p>4、 <code>make CORSS_COMPILE = arm-none-linux-gnueabi-</code> 配置编译</p>\n<p>5、 <code>make install</code> 安装</p>\n<h3>QT 的安装</h3>\n<p>1、 获取源码包，示范 qt.tar.gz</p>\n<p>2、 解压源码包到当前目录 <code>tar -zxvf qt.tar.gz</code></p>\n<p>3、 <code>cd qt &#x26;&#x26; ./configure -embedded [architechture] --prefix=/opt/qt</code></p>\n<p>4、 <code>make &#x26;&#x26; make install</code></p>\n<p>5、 设置环境变量 <code>export PATH=$PATH:/opt/qt/bin &#x26;&#x26; source .bash_profile</code></p>\n<p>6、 <code>which qmake</code></p>\n<h3>NFS</h3>\n<p>1、 <code>setup</code> system service 选 nfs</p>\n<p>2、 退出 setup <code>vi /etc/exports</code></p>\n<p>3、 <code>service nfs restart</code></p>\n<p>4、 <code>ifconfig</code> 查看网卡获得 ip</p>\n<p>5、 <code>mount ip：</code></p>\n<h3>TFTP</h3>\n<p>1、 <code>setup</code> system service 选 tftp</p>\n<p>2、 去掉 ipchains 和 iptables</p>\n<p>3、 Firewall configuration 选 Nofirewall</p>\n<p>4、 退出 setup <code>service xinetd restart</code></p>\n<h3>字符设备的代码</h3>\n<pre><code class=\"language-c\">static struct file_operations keybd_fops = {\r\n    open : keybd_open,\r\n    read : keybd_read,\r\n    release : keybd_release,\r\n};\r\nint keybd_open(struct inode *inode, struct file *filp)\r\n{\r\n    printk(\"open ok\\n\");\r\n    return 0;\r\n}\r\nssize_t keybd_read(struct file *fp, char *buf,\r\n                   size_t size)\r\n{\r\n    ……\r\n}\r\nint keybd_release(struct inode *inode, struct file *filp)\r\n{\r\n    printk(\"release ok\\n\");\r\n    return 0;\r\n}\r\nssize_t led_write(struct file *fp, char *buf,\r\n                  size_t size)\r\n{\r\n    ……\r\n}\r\nint __init keybd_init(void)\r\n{\r\n    ……\r\n}\r\nstatic void __exit keybd_exit(void)\r\n{\r\n    devfs_unregister(devfs_keybd);\r\n}\r\nmodule_init(keybd_init);\r\nmodule_exit(keybd_exit);\n</code></pre>\n<h3>按键驱动</h3>\n<pre><code class=\"language-c\">// 初始化设备，将引脚设置为中断模式\r\nvoid init_dev(void)\r\n{\r\n    s3c_gpio_cfgpin(key_table[0], S3C_GPIO_SFN(2));\r\n    s3c_gpio_cfgpin(key_table[1], S3C_GPIO_SFN(2));\r\n    s3c_gpio_cfgpin(key_table[2], S3C_GPIO_SFN(2));\r\n    s3c_gpio_cfgpin(key_table[3], S3C_GPIO_SFN(2));\r\n    s3c_gpio_cfgpin(key_table[4], S3C_GPIO_SFN(2));\r\n    s3c_gpio_cfgpin(key_table[5], S3C_GPIO_SFN(2));\r\n\r\n    unsigned int tmp;\r\n    tmp = readl(S3C64XX_GPNCON);\r\n    printk(\"%x\\n\", tmp);\r\n}\r\n\r\n// 请求中断\r\nret = request_irq(key_irqs[num].irq, keys_interrupt, key_irqs[num].flags, key_irqs[num].name, (void *)&#x26;key_irqs[num]);\r\n\r\n// 等待中断触发事件\r\nwait_event_interruptible(key_waitq, ev_press);\r\n\r\n//当中断发生时，调用中断处理函数。当外部中断发生时，request_irq()当中最后一个参数将提供给中断处理函数\r\nstatic irqreturn_t keys_interrupt(int irq, void *dev_id)\r\n{\r\n    struct key_irq *key_irqs = (struct key_irq *)dev_id;\r\n    int down;\r\n    int number;\r\n    unsigned tmp;\r\n\r\n    number = key_irqs->number;\r\n    printk(\"number = %d\\n\", number);\r\n    switch (number)\r\n    {\r\n    case 0:\r\n    case 1:\r\n    case 2:\r\n    case 3:\r\n    case 4:\r\n    case 5:\r\n        tmp = readl(S3C64XX_GPNDAT);\r\n        down = !(tmp &#x26; (1 &#x3C;&#x3C; number));\r\n        break;\r\n\r\n    default:\r\n        down = 0;\r\n    }\r\n\r\n    if (down != (key_values[number] &#x26; 1))\r\n    {\r\n        key_values[number] = '0' + down;\r\n        ev_press = 1;\r\n\r\n        wake_up_interruptible(&#x26;key_waitq);\r\n    }\r\n\r\n    printk(\"interrupt\\n\");\r\n    return IRQ_RETVAL(IRQ_HANDLED);\r\n}\r\n\r\n// 释放中断\r\nfree_irq(key_irqs[i].irq, (void *)&#x26;key_irqs[i]);\r\n\n</code></pre>\n<h3>LED 驱动程序的动态加载</h3>\n<p>1、 开发板上电，进入 NFS</p>\n<p>2、 将 led_app 和 led.ko 拷贝到挂载的 NFS 文件系统中</p>\n<p>3、 切换到串口终端 <code>ls</code> 查看是否拷贝成功</p>\n<p>4、 动态加载驱动代码 <code>insmod led.ko</code></p>\n<p>5、 查看驱动设备号 <code>cat /proc/devices</code></p>\n<p>6、 根据驱动设备号创建设备文件 <code>mknod /dev/myled c 253 0</code></p>\n<p>7、 <code>./led_app 1</code> 来测试灯是否亮；<code>./led_app 0</code> 测试关闭灯</p>\n<h3>makefile 注释样例</h3>\n<h4>样例 1</h4>\n<pre><code class=\"language-makefile\">edit: main.o kbd.o command.o\r\n# 定义目标文件 edit 和源文件 main.o 等\r\n    gcc -o edit main.o kbd.o command.o\r\n    #定义 edit 的编译方法\r\nmain.o: main.c defs.h\r\n# 定义目标文件 main.o 和源文件 main.c defs.h\r\n    gcc -c main.c\r\n    # 定义 main.o 的编译方法\r\nkbd.o: kbd.c defs.h command.h\r\n# 定义目标文件kbd.o和源文件\r\n    gcc -c kbd.c\r\n    # 定义 kbd.o 的编译方法\r\ncommand.o: command.c defs.h command.h\r\n# 定义目标文件command.o和源文件\r\n    gcc -c command.c\r\n    # 定义 command.p 的编译方法\r\nclean:\r\n# 定义伪目标\r\n    rm edit main.o kbd.o command.o display.o insert.o\r\n    # 删除目标文件\n</code></pre>\n<h4>样例 2</h4>\n<pre><code class=\"language-makefile\">CC = /opt/host/armv4l/bin/armv4l-unknown-linux-gcc\r\n# 定义 gcc\r\nLD = /opt/host/armv4l/bin/armv4l-unknown-linux-ld\r\n# 定义 ld\r\nCFLAGS = -I/HHARM9-EDU/kernel/include/linux -Wall\r\n# 定义编译选项\r\nled.o: led.c\r\n# 定义目标和源文件\r\n    $(CC) $(CFLAGS) -g led.c -o led\r\n    # 编译方法\r\n    cp led.o / -f\r\n    # 复制 led.o 到 /\r\n.PHONY: clean\r\n# 定义伪目标\r\nclean:\r\n# 定义clean\r\n    -rm -f *.o\r\n    # 删除中间文件\n</code></pre>"}},"pageContext":{"id":"fde41c7a-6536-5376-a745-73cbb0e6c57e","parent__name":"Start-Linux","__params":{"parent__name":"start-linux"}}},"staticQueryHashes":[]}